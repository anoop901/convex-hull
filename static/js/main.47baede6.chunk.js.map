{"version":3,"sources":["util/chain.ts","util/iterables.ts","util/Vector.ts","convexHull.ts","util/geometry.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Chain","value","transformFn","this","chain","initialValue","zip","allIntegersStartingAt","iterate","drop","n","iterable","iter","Symbol","iterator","i","next","done","firstIterable","secondIterable","firstIterator","secondIterator","firstDone","first","secondDone","second","map","fn","t","f","reduce","firstIteratorResult","Error","result","enumerate","then","index","end","start","initial","current","vectorFromPoints","fromPoint","toPoint","x","y","convexHull","points","pred","a","b","leftmostPointIndex","leftmostPoint","currentPointIndex","currentPoint","bestPointSoFarIndex","bestPointSoFar","otherPointIndex","otherPoint","point1","point2","point3","vector1","vector2","isOrientationClockwise","width","App","React","useState","setPoints","setPoint","point","set","convexHullPoints","height","onDblClick","event","pointerPosition","target","getStage","getPointerPosition","stroke","flatMap","lineJoin","lineCap","hitStrokeWidth","closed","radius","fill","draggable","onDragMove","type","min","max","onChange","valueAsNumber","onClick","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"mNAAMA,E,WACJ,WAA6BC,GAAW,yBAAXA,Q,iDACrBC,GACN,OAAO,IAAIF,EAAME,EAAYC,KAAKF,U,4BAGlC,OAAOE,KAAKF,U,KAID,SAASG,EAASC,GAC/B,OAAO,IAAIL,EAAMK,G,uCCKFC,G,WA4DAC,G,WA8CAC,GAxHV,SAASC,EAAQC,GACtB,iBAAO,WAAWC,GAAX,iFAEL,IADMC,EAAOD,EAASE,OAAOC,YACpBC,EAAI,EAAGA,EAAIL,EAAGK,IACrBH,EAAKI,OAHF,EAKiBJ,EAAKI,OAArBf,EALD,EAKCA,MAAOgB,EALR,EAKQA,KALR,UAMGA,EANH,iBAOH,OAPG,SAOGhB,EAPH,SAQgBW,EAAKI,OAArBf,EARA,EAQAA,MAAOgB,EARP,EAQOA,KARP,0DAaF,SAAUX,EACfY,EACAC,GAFK,qFAICC,EAAgBF,EAAcL,OAAOC,YACrCO,EAAiBF,EAAeN,OAAOC,YALxC,YAOuCM,EAAcJ,OAA1CM,EAPX,EAOKL,KAAwBM,EAP7B,EAOsBtB,MAPtB,EAQyCoB,EAAeL,OAA7CQ,EARX,EAQKP,KAAyBQ,EAR9B,EAQuBxB,MACrBqB,GAAcE,EAThB,iBAUD,OAVC,SAUK,CAAED,QAAOE,UAVd,0HAsBA,SAASC,EAAUC,GACxB,iBAAO,WAAWhB,GAAX,yFACWA,GADX,wDAEH,OADSiB,EADN,iBAEGD,EAAGC,GAFN,oHAAAC,IAAA,4EAOF,SAASC,EAAUH,GACxB,OAAO,SAAChB,GACN,IAAMG,EAAWH,EAASE,OAAOC,YAC3BiB,EAAsBjB,EAASE,OACrC,GAAIe,EAAoBd,KACtB,MAAM,IAAIe,MAAM,gCAKlB,IAFA,IAAIC,EAASF,EAAoB9B,MAPE,EAQba,EAASE,OAAzBf,EAR6B,EAQ7BA,MAAOgB,EARsB,EAQtBA,MACLA,GAAM,CACZgB,EAASN,EAAGM,EAAQhC,GADR,MAEOa,EAASE,OAAzBf,EAFS,EAETA,MAAOgB,EAFE,EAEFA,KAEZ,OAAOgB,GAQJ,SAASC,EACdvB,GAEA,OAAOP,EAAME,EAAIK,EAAUJ,MACxB4B,KAAKT,GAAI,gBAAGH,EAAH,EAAGA,MAAH,MAAwB,CAAEa,MAA1B,EAAUX,OAA+BxB,MAAOsB,OACzDc,MAGE,SAAU9B,IAAV,qFAAgC+B,EAAhC,+BAAwC,EACpC5B,EAAI4B,EADR,OAEH,OAFG,SAEG5B,EAFH,OACqBA,IADrB,sDA8CA,SAAUF,EAAW+B,EAAYZ,GAAjC,uEACDa,EAAUD,EADT,OAGH,OAHG,SAGGC,EAHH,OAIHA,EAAUb,EAAGa,GAJV,sDCnHA,SAASC,EAAiBC,EAAkBC,GACjD,MAAO,CAAEC,EAAGD,EAAQC,EAAIF,EAAUE,EAAGC,EAAGF,EAAQE,EAAIH,EAAUG,GCKjD,SAASC,EAAWC,GAA2B,IFmDlCpB,EAkBSqB,EErEwB,EACC5C,EAAM2C,GAC/DZ,KAAKD,GACLC,MFgDuBR,EEhDZ,qBAAG1B,MAAS2C,GFiDnBd,GAAU,SAACmB,EAAGC,GAAJ,OAAWvB,EAAGuB,GAAKvB,EAAGsB,GAAKC,EAAID,OEhD7CZ,MAHYc,EAD4C,EACnDf,MAAkCgB,EADiB,EACxBnD,MAKnC,OAAOG,EACLI,EACE,CACEyB,OAAQ,GACRoB,kBAAmBF,EACnBG,aAAcF,IAEhB,YAAkD,IFsF9BJ,EEtFjBf,EAA8C,EAA9CA,OAAQoB,EAAsC,EAAtCA,kBAAmBC,EAAmB,EAAnBA,aAAmB,EACKlD,EAAM2C,GACvDZ,KAAKD,GACLC,MFmFea,EEjFZ,qBAAGZ,QACmBiB,GFiFlC,UAAO,WAAW1C,GAAX,yFACWA,GADX,4DACMiB,EADN,SAECoB,EAAKpB,GAFN,gBAGD,OAHC,SAGKA,EAHL,qHAAAC,IAAA,8EE9EEM,KACCL,GACE,kBACWyB,EADX,EACInB,MAAmCoB,EADvC,EACgCvD,MACrBwD,EAFX,EAEIrB,MAA+BsB,EAFnC,EAE4BzD,MAF5B,OClCP,SACL0D,EACAC,EACAC,GAEA,OFG2BC,EEDvBrB,EAAiBkB,EAAQC,GFCeG,EEAxCtB,EAAiBmB,EAAQC,GFCtBC,EAAQlB,EAAImB,EAAQlB,EAAIiB,EAAQjB,EAAIkB,EAAQnB,EEA7C,EFDD,IAAsBkB,EAAiBC,EC8B9BC,CAAuBV,EAAcE,EAAgBE,GACjD,CAAEtB,MAAOmB,EAAqBtD,MAAOuD,GACrC,CAAEpB,MAAOqB,EAAiBxD,MAAOyD,OAG1CrB,MACH,MAAO,CACLgB,kBAtB6C,EACvCjB,MAsBNkB,aAvB6C,EAChBrD,MAuB7BgC,OAAO,GAAD,mBAAMA,GAAN,CAAcqB,SAKzBnB,KAAK1B,EAAK,IACV0B,MF0BgCa,EExB7B,qBAAGK,oBAA8CF,GFyBhD,SAACxC,GAAqC,IAAD,gBACtBA,GADsB,IAC1C,2BAA8B,CAAC,IAApBV,EAAmB,QAC5B,GAAI+C,EAAK/C,GACP,OAAOA,GAH+B,8BAM1C,OAAO,QE5BNkC,MAAK,SAACS,GACL,GAAS,MAALA,EACF,MAAM,IAAIZ,MAAM,eAElB,OAAOY,KAERT,MAAK,qBAAGF,UACRI,ME9DL,IAAM4B,EAAQ,IAkJCC,MA9If,WAAgB,IAAD,EACeC,IAAMC,SAAkB,CAClD,CAAExB,EAAG,IAAKC,EAAG,KACb,CAAED,EAAG,IAAKC,EAAG,KACb,CAAED,EAAG,IAAKC,EAAG,KACb,CAAED,EAAG,IAAKC,EAAG,OALF,mBACNE,EADM,KACEsB,EADF,KAYb,SAASC,EAASlC,EAAemC,GAC/BF,EAAUG,YAAIzB,EAAQX,EAAOmC,IAG/B,IAAME,EAAmB3B,EAAWC,GAEpC,OACE,gCACE,gCACE,6DACA,eAAC,IAAD,CACEkB,MAAOA,EACPS,OA3BK,IA4BLC,WAAY,SAACC,GAAW,IAAD,EAjBbL,EAkBFM,EAAe,UAAGD,EAAME,OAC3BC,kBADkB,aAAG,EAEpBC,qBACCH,IArBGN,EAwBC,CAAE3B,EAAGiC,EAAgBjC,EAAGC,EAAGgC,EAAgBhC,GAvB5DwB,EAAU,GAAD,mBAAKtB,GAAL,CAAawB,OAalB,UAaE,cAAC,IAAD,UACE,cAAC,IAAD,CACE3B,EAAG,EACHC,EAAG,EACHoB,MAAOA,EACPS,OA3CC,IA4CDO,OAAQ,YAGZ,eAAC,IAAD,WACE,cAAC,IAAD,CACElC,OAAQ0B,EAAiBS,SAAQ,kBAAc,CAAd,EAAGtC,EAAH,EAAMC,MACvCoC,OAAO,SACPE,SAAS,QACTC,QAAQ,QACRC,eAAgB,EAChBC,QAAM,IAEPb,EAAiB/C,KAAI,WAAWU,GAAX,IAAGQ,EAAH,EAAGA,EAAGC,EAAN,EAAMA,EAAN,OACpB,cAAC,IAAD,CAEED,EAAGA,EACHC,EAAGA,EACH0C,OAAQA,GACRC,KAAK,UAJApD,SAQX,cAAC,IAAD,UACGW,EAAOrB,KAAI,SAAC6C,EAAOnC,GAAR,OACV,cAAC,IAAD,CACEqD,WAAS,EAET7C,EAAG2B,EAAM3B,EACTC,EAAG0B,EAAM1B,EACT0C,OAxED,GAyECC,KAAK,QACLP,OAAO,YACPS,WAAY,SAACd,GACXN,EAASlC,EAAO,CAAEQ,EAAGgC,EAAME,OAAOlC,IAAKC,EAAG+B,EAAME,OAAOjC,QAPpDT,cAef,wCACA,8BACE,kCACE,gCACE,+BACE,mCACA,wCAGJ,gCACGW,EAAOrB,KAAI,SAAC6C,EAAOnC,GAAR,OACV,+BACE,6BACE,uBACEuD,KAAK,SACL1F,MAAOsE,EAAM3B,EACbgD,IAAK,EACLC,IAAK5B,EACL6B,SAAU,SAAClB,GACTN,EAASlC,EAAO,CACdQ,EAAGgC,EAAME,OAAOiB,cAChBlD,EAAGE,EAAOX,GAAOS,SAKzB,6BAEI,uBACE8C,KAAK,SACL1F,MAAOsE,EAAM1B,EACb+C,IAAK,EACLC,IAAK5B,EACL6B,SAAU,SAAClB,GACTN,EAASlC,EAAO,CACdQ,EAAGG,EAAOX,GAAOQ,EACjBC,EAAG+B,EAAME,OAAOiB,uBAzBnB3D,aAoCjB,8BACE,wBACE4D,QAAS,WACP3B,EAAU,GAAD,mBAAKtB,GAAL,CAAa,CAAEH,EAAGqB,IAAWpB,EAAG6B,SAF7C,uBC9HOuB,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBhE,MAAK,YAAkD,IAA/CiE,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCJdO,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1BZ,M","file":"static/js/main.47baede6.chunk.js","sourcesContent":["class Chain<T> {\n  constructor(private readonly value: T) {}\n  then<U>(transformFn: (arg: T) => U): Chain<U> {\n    return new Chain(transformFn(this.value));\n  }\n  end(): T {\n    return this.value;\n  }\n}\n\nexport default function chain<T>(initialValue: T): Chain<T> {\n  return new Chain(initialValue);\n}\n","import chain from \"./chain\";\n\nexport function drop<T>(n: number) {\n  return function* (iterable: Iterable<T>): Generator<T> {\n    const iter = iterable[Symbol.iterator]();\n    for (let i = 0; i < n; i++) {\n      iter.next();\n    }\n    let { value, done } = iter.next();\n    while (!done) {\n      yield value;\n      ({ value, done } = iter.next());\n    }\n  };\n}\n\nexport function* zip<T, U>(\n  firstIterable: Iterable<T>,\n  secondIterable: Iterable<U>\n): Generator<{ first: T; second: U }> {\n  const firstIterator = firstIterable[Symbol.iterator]();\n  const secondIterator = secondIterable[Symbol.iterator]();\n  while (true) {\n    const { done: firstDone, value: first } = firstIterator.next();\n    const { done: secondDone, value: second } = secondIterator.next();\n    if (!firstDone && !secondDone) {\n      yield { first, second };\n    } else {\n      break;\n    }\n  }\n}\n\nexport function pairs<T>(offset = 1) {\n  return (iterable: Iterable<T>): Iterable<{ first: T; second: T }> =>\n    chain(zip(iterable, drop<T>(offset)(iterable))).end();\n}\n\nexport function map<T, U>(fn: (arg: T) => U) {\n  return function* (iterable: Iterable<T>): Generator<U> {\n    for (const t of iterable) {\n      yield fn(t);\n    }\n  };\n}\n\nexport function reduce<T>(fn: (a: T, b: T) => T) {\n  return (iterable: Iterable<T>): T => {\n    const iterator = iterable[Symbol.iterator]();\n    const firstIteratorResult = iterator.next();\n    if (firstIteratorResult.done) {\n      throw new Error(\"cannot reduce empty iterable\");\n    }\n\n    let result = firstIteratorResult.value;\n    let { value, done } = iterator.next();\n    while (!done) {\n      result = fn(result, value);\n      ({ value, done } = iterator.next());\n    }\n    return result;\n  };\n}\n\nexport function minBy<T, U>(fn: (arg: T) => U): (iterable: Iterable<T>) => T {\n  return reduce<T>((a, b) => (fn(b) < fn(a) ? b : a));\n}\n\nexport function enumerate<T>(\n  iterable: Iterable<T>\n): Iterable<{ index: number; value: T }> {\n  return chain(zip(iterable, allIntegersStartingAt()))\n    .then(map(({ first, second }) => ({ index: second, value: first })))\n    .end();\n}\n\nexport function* allIntegersStartingAt(start = 0): Generator<number> {\n  for (let n = start; true; n++) {\n    yield n;\n  }\n}\n\nexport function findFirstMatching<T>(pred: (arg: T) => boolean) {\n  return (iterable: Iterable<T>): T | null => {\n    for (const value of iterable) {\n      if (pred(value)) {\n        return value;\n      }\n    }\n    return null;\n  };\n}\n\nexport function allMatch<T>(pred: (t: T) => boolean) {\n  return (iterable: Iterable<T>): boolean => {\n    return chain(iterable)\n      .then(map(pred))\n      .then(fold(true, (a, b) => a && b))\n      .end();\n  };\n}\n\nexport function fold<A, T>(initial: A, fn: (acc: A, x: T) => A) {\n  return (iterable: Iterable<T>): A => {\n    let result = initial;\n    for (const t of iterable) {\n      result = fn(result, t);\n    }\n    return result;\n  };\n}\n\nexport function filter<T>(pred: (arg: T) => boolean) {\n  return function* (iterable: Iterable<T>): Generator<T> {\n    for (const t of iterable) {\n      if (pred(t)) {\n        yield t;\n      }\n    }\n  };\n}\n\nexport function* iterate<T>(initial: T, fn: (arg: T) => T): Generator<T> {\n  let current = initial;\n  while (true) {\n    yield current;\n    current = fn(current);\n  }\n}\n","import Point from \"./Point\";\n\nexport default interface Vector {\n  x: number;\n  y: number;\n}\n\nexport function vectorFromPoints(fromPoint: Point, toPoint: Point) {\n  return { x: toPoint.x - fromPoint.x, y: toPoint.y - fromPoint.y };\n}\n\nexport function crossProduct(vector1: Vector, vector2: Vector): number {\n  return vector1.x * vector2.y - vector1.y * vector2.x;\n}\n","import Point from \"./util/Point\";\nimport chain from \"./util/chain\";\nimport {\n  drop,\n  enumerate,\n  filter,\n  findFirstMatching,\n  iterate,\n  minBy,\n  reduce,\n} from \"./util/iterables\";\nimport { isOrientationClockwise } from \"./util/geometry\";\n\nexport default function convexHull(points: Point[]): Point[] {\n  const { index: leftmostPointIndex, value: leftmostPoint } = chain(points)\n    .then(enumerate)\n    .then(minBy(({ value: { x } }) => x))\n    .end();\n\n  return chain(\n    iterate(\n      {\n        result: [] as Point[],\n        currentPointIndex: leftmostPointIndex,\n        currentPoint: leftmostPoint,\n      },\n      ({ result, currentPointIndex, currentPoint }) => {\n        const { index: nextPointIndex, value: nextPoint } = chain(points)\n          .then(enumerate)\n          .then(\n            filter(\n              ({ index: otherPointIndex }) =>\n                otherPointIndex !== currentPointIndex\n            )\n          )\n          .then(\n            reduce(\n              (\n                { index: bestPointSoFarIndex, value: bestPointSoFar },\n                { index: otherPointIndex, value: otherPoint }\n              ) =>\n                isOrientationClockwise(currentPoint, bestPointSoFar, otherPoint)\n                  ? { index: bestPointSoFarIndex, value: bestPointSoFar }\n                  : { index: otherPointIndex, value: otherPoint }\n            )\n          )\n          .end();\n        return {\n          currentPointIndex: nextPointIndex,\n          currentPoint: nextPoint,\n          result: [...result, currentPoint],\n        };\n      }\n    )\n  )\n    .then(drop(1))\n    .then(\n      findFirstMatching(\n        ({ currentPointIndex }) => currentPointIndex === leftmostPointIndex\n      )\n    )\n    .then((x) => {\n      if (x == null) {\n        throw new Error(\"unreachable\");\n      }\n      return x;\n    })\n    .then(({ result }) => result)\n    .end();\n}\n","import Point from \"./Point\";\nimport { crossProduct, vectorFromPoints } from \"./Vector\";\n\nexport function isOrientationClockwise(\n  point1: Point,\n  point2: Point,\n  point3: Point\n): boolean {\n  return (\n    crossProduct(\n      vectorFromPoints(point1, point2),\n      vectorFromPoints(point2, point3)\n    ) > 0\n  );\n}\n","import { set } from \"immutable\";\nimport React from \"react\";\nimport { Circle, Layer, Line, Rect, Stage } from \"react-konva\";\nimport convexHull from \"./convexHull\";\nimport Point from \"./util/Point\";\n\nconst width = 500;\nconst height = 500;\nconst radius = 10;\n\nfunction App() {\n  const [points, setPoints] = React.useState<Point[]>([\n    { x: 100, y: 100 },\n    { x: 100, y: 200 },\n    { x: 200, y: 200 },\n    { x: 200, y: 300 },\n  ]);\n\n  function addPoint(point: Point) {\n    setPoints([...points, point]);\n  }\n\n  function setPoint(index: number, point: Point) {\n    setPoints(set(points, index, point));\n  }\n\n  const convexHullPoints = convexHull(points);\n\n  return (\n    <div>\n      <div>\n        <p>Double-click to add a point.</p>\n        <Stage\n          width={width}\n          height={height}\n          onDblClick={(event) => {\n            const pointerPosition = event.target\n              .getStage()\n              ?.getPointerPosition();\n            if (!pointerPosition) {\n              return;\n            }\n            addPoint({ x: pointerPosition.x, y: pointerPosition.y });\n          }}\n        >\n          <Layer>\n            <Rect\n              x={0}\n              y={0}\n              width={width}\n              height={height}\n              stroke={\"black\"}\n            ></Rect>\n          </Layer>\n          <Layer>\n            <Line\n              points={convexHullPoints.flatMap(({ x, y }) => [x, y])}\n              stroke=\"orange\"\n              lineJoin=\"round\"\n              lineCap=\"round\"\n              hitStrokeWidth={0}\n              closed\n            />\n            {convexHullPoints.map(({ x, y }, index) => (\n              <Circle\n                key={index}\n                x={x}\n                y={y}\n                radius={radius * 1.5}\n                fill=\"orange\"\n              />\n            ))}\n          </Layer>\n          <Layer>\n            {points.map((point, index) => (\n              <Circle\n                draggable\n                key={index}\n                x={point.x}\n                y={point.y}\n                radius={radius}\n                fill=\"green\"\n                stroke=\"darkgreen\"\n                onDragMove={(event) => {\n                  setPoint(index, { x: event.target.x(), y: event.target.y() });\n                }}\n              />\n            ))}\n          </Layer>\n        </Stage>\n      </div>\n\n      <h1>Points</h1>\n      <div>\n        <table>\n          <thead>\n            <tr>\n              <td>x</td>\n              <td>y</td>\n            </tr>\n          </thead>\n          <tbody>\n            {points.map((point, index) => (\n              <tr key={index}>\n                <td>\n                  <input\n                    type=\"number\"\n                    value={point.x}\n                    min={0}\n                    max={width}\n                    onChange={(event) => {\n                      setPoint(index, {\n                        x: event.target.valueAsNumber,\n                        y: points[index].y,\n                      });\n                    }}\n                  ></input>\n                </td>\n                <td>\n                  {\n                    <input\n                      type=\"number\"\n                      value={point.y}\n                      min={0}\n                      max={width}\n                      onChange={(event) => {\n                        setPoint(index, {\n                          x: points[index].x,\n                          y: event.target.valueAsNumber,\n                        });\n                      }}\n                    ></input>\n                  }\n                </td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n      <div>\n        <button\n          onClick={() => {\n            setPoints([...points, { x: width / 2, y: height / 2 }]);\n          }}\n        >\n          Add\n        </button>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}