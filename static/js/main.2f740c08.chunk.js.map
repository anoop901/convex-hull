{"version":3,"sources":["util/chain.ts","util/iterables.ts","util/Vector.ts","util/geometry.ts","util/comparators.ts","convexHull.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Chain","value","transformFn","this","chain","initialValue","zip","allIntegersStartingAt","iterate","drop","n","iterable","iter","Symbol","iterator","i","next","done","firstIterable","secondIterable","firstIterator","secondIterator","firstDone","first","secondDone","second","map","fn","t","f","reduce","firstIteratorResult","Error","result","enumerate","then","index","end","start","fold","initial","current","vectorFromPoints","fromPoint","toPoint","x","y","crossProduct","vector1","vector2","distanceSq","point1","point2","vector","compareByNumber","a","b","convexHull","points","comparator","pred","comparators","compareInOrder","leftmostPointIndex","leftmostPoint","currentPointIndex","currentPoint","bestPointSoFarIndex","bestPointSoFar","collinearPoints","otherPointIndex","otherPoint","cp","width","App","React","useState","setPoints","setPoint","point","set","convexHullPoints","height","onDblClick","event","pointerPosition","target","getStage","getPointerPosition","stroke","flatMap","lineJoin","lineCap","hitStrokeWidth","closed","radius","fill","draggable","onDragMove","type","min","max","onChange","valueAsNumber","onClick","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2f740c08.chunk.js","sourcesContent":["class Chain<T> {\n  constructor(private readonly value: T) {}\n  then<U>(transformFn: (arg: T) => U): Chain<U> {\n    return new Chain(transformFn(this.value));\n  }\n  end(): T {\n    return this.value;\n  }\n}\n\nexport default function chain<T>(initialValue: T): Chain<T> {\n  return new Chain(initialValue);\n}\n","import chain from \"./chain\";\n\nexport function drop<T>(n: number) {\n  return function* (iterable: Iterable<T>): Generator<T> {\n    const iter = iterable[Symbol.iterator]();\n    for (let i = 0; i < n; i++) {\n      iter.next();\n    }\n    let { value, done } = iter.next();\n    while (!done) {\n      yield value;\n      ({ value, done } = iter.next());\n    }\n  };\n}\n\nexport function* zip<T, U>(\n  firstIterable: Iterable<T>,\n  secondIterable: Iterable<U>\n): Generator<{ first: T; second: U }> {\n  const firstIterator = firstIterable[Symbol.iterator]();\n  const secondIterator = secondIterable[Symbol.iterator]();\n  while (true) {\n    const { done: firstDone, value: first } = firstIterator.next();\n    const { done: secondDone, value: second } = secondIterator.next();\n    if (!firstDone && !secondDone) {\n      yield { first, second };\n    } else {\n      break;\n    }\n  }\n}\n\nexport function pairs<T>(offset = 1) {\n  return (iterable: Iterable<T>): Iterable<{ first: T; second: T }> =>\n    chain(zip(iterable, drop<T>(offset)(iterable))).end();\n}\n\nexport function map<T, U>(fn: (arg: T) => U) {\n  return function* (iterable: Iterable<T>): Generator<U> {\n    for (const t of iterable) {\n      yield fn(t);\n    }\n  };\n}\n\nexport function reduce<T>(fn: (a: T, b: T) => T) {\n  return (iterable: Iterable<T>): T => {\n    const iterator = iterable[Symbol.iterator]();\n    const firstIteratorResult = iterator.next();\n    if (firstIteratorResult.done) {\n      throw new Error(\"cannot reduce empty iterable\");\n    }\n\n    let result = firstIteratorResult.value;\n    let { value, done } = iterator.next();\n    while (!done) {\n      result = fn(result, value);\n      ({ value, done } = iterator.next());\n    }\n    return result;\n  };\n}\n\nexport function min<T>(\n  comparator: (a: T, b: T) => number\n): (iterable: Iterable<T>) => T {\n  return reduce<T>((a, b) => (comparator(b, a) < 0 ? b : a));\n}\n\nexport function minBy<T, U>(fn: (arg: T) => U): (iterable: Iterable<T>) => T {\n  return reduce<T>((a, b) => (fn(b) < fn(a) ? b : a));\n}\n\nexport function maxBy<T, U>(fn: (arg: T) => U): (iterable: Iterable<T>) => T {\n  return reduce<T>((a, b) => (fn(b) > fn(a) ? b : a));\n}\n\nexport function enumerate<T>(\n  iterable: Iterable<T>\n): Iterable<{ index: number; value: T }> {\n  return chain(zip(iterable, allIntegersStartingAt()))\n    .then(map(({ first, second }) => ({ index: second, value: first })))\n    .end();\n}\n\nexport function* allIntegersStartingAt(start = 0): Generator<number> {\n  for (let n = start; true; n++) {\n    yield n;\n  }\n}\n\nexport function findFirstMatching<T>(pred: (arg: T) => boolean) {\n  return (iterable: Iterable<T>): T | null => {\n    for (const value of iterable) {\n      if (pred(value)) {\n        return value;\n      }\n    }\n    return null;\n  };\n}\n\nexport function allMatch<T>(pred: (t: T) => boolean) {\n  return (iterable: Iterable<T>): boolean => {\n    return chain(iterable)\n      .then(map(pred))\n      .then(fold(true, (a, b) => a && b))\n      .end();\n  };\n}\n\nexport function fold<A, T>(initial: A, fn: (acc: A, x: T) => A) {\n  return (iterable: Iterable<T>): A => {\n    let result = initial;\n    for (const t of iterable) {\n      result = fn(result, t);\n    }\n    return result;\n  };\n}\n\nexport function filter<T>(pred: (arg: T) => boolean) {\n  return function* (iterable: Iterable<T>): Generator<T> {\n    for (const t of iterable) {\n      if (pred(t)) {\n        yield t;\n      }\n    }\n  };\n}\n\nexport function* iterate<T>(initial: T, fn: (arg: T) => T): Generator<T> {\n  let current = initial;\n  while (true) {\n    yield current;\n    current = fn(current);\n  }\n}\n","import Point from \"./Point\";\n\nexport default interface Vector {\n  x: number;\n  y: number;\n}\n\nexport function vectorFromPoints(fromPoint: Point, toPoint: Point) {\n  return { x: toPoint.x - fromPoint.x, y: toPoint.y - fromPoint.y };\n}\n\nexport function crossProduct(vector1: Vector, vector2: Vector): number {\n  return vector1.x * vector2.y - vector1.y * vector2.x;\n}\n\nexport function magnitudeSq(vector: Vector) {\n  return vector.x * vector.x + vector.y * vector.y;\n}\n","import Point from \"./Point\";\nimport { crossProduct, magnitudeSq, vectorFromPoints } from \"./Vector\";\n\nexport function distanceSq(point1: Point, point2: Point): number {\n  return magnitudeSq(vectorFromPoints(point1, point2));\n}\n\nexport function arePointsCollinear(\n  point1: Point,\n  point2: Point,\n  point3: Point\n): boolean {\n  return (\n    crossProduct(\n      vectorFromPoints(point1, point2),\n      vectorFromPoints(point2, point3)\n    ) === 0\n  );\n}\n\n// assumes a left-handed coordinate system, e.g. the canvas\nexport function isOrientationClockwise(\n  point1: Point,\n  point2: Point,\n  point3: Point\n): boolean {\n  return (\n    crossProduct(\n      vectorFromPoints(point1, point2),\n      vectorFromPoints(point2, point3)\n    ) > 0\n  );\n}\n","export function compareByNumber<T>(fn: (arg: T) => number) {\n  return (a: T, b: T): number => fn(a) - fn(b);\n}\n\nexport function compareByString<T>(fn: (arg: T) => string) {\n  return (a: T, b: T): number => (fn(a) === fn(b) ? 0 : fn(a) > fn(b) ? 1 : -1);\n}\n\nexport function compareInOrder<T>(...comparators: ((a: T, b: T) => number)[]) {\n  return (a: T, b: T): number => {\n    for (const comparator of comparators) {\n      const result = comparator(a, b);\n      if (result !== 0) {\n        return result;\n      }\n    }\n    return 0;\n  };\n}\n\nexport function reverse<T>(comparator: (a: T, b: T) => number) {\n  return (a: T, b: T): number => {\n    return -comparator(a, b);\n  };\n}\n","import Point from \"./util/Point\";\nimport chain from \"./util/chain\";\nimport {\n  drop,\n  enumerate,\n  filter,\n  findFirstMatching,\n  fold,\n  iterate,\n  min,\n} from \"./util/iterables\";\nimport { crossProduct, vectorFromPoints } from \"./util/Vector\";\nimport { distanceSq } from \"./util/geometry\";\nimport { compareByNumber, compareInOrder } from \"./util/comparators\";\n\nexport default function convexHull(points: Point[]): Point[] {\n  const { index: leftmostPointIndex, value: leftmostPoint } = chain(points)\n    .then(enumerate)\n    .then(\n      min(\n        compareInOrder(\n          compareByNumber(({ value: { x } }) => x),\n          compareByNumber(({ value: { y } }) => y)\n        )\n      )\n    )\n    .end();\n\n  return chain(\n    iterate(\n      {\n        result: [] as Point[],\n        currentPointIndex: leftmostPointIndex,\n        currentPoint: leftmostPoint,\n      },\n      ({ result, currentPointIndex, currentPoint }) => {\n        const { bestPointSoFarIndex, bestPointSoFar, collinearPoints } = chain(\n          points\n        )\n          .then(enumerate)\n          .then(\n            filter(\n              ({ index: otherPointIndex }) =>\n                otherPointIndex !== currentPointIndex\n            )\n          )\n          .then(\n            fold(\n              {\n                bestPointSoFarIndex: null as number | null,\n                bestPointSoFar: null as Point | null,\n                collinearPoints: [] as Point[],\n              },\n              (\n                { bestPointSoFarIndex, bestPointSoFar, collinearPoints },\n                { index: otherPointIndex, value: otherPoint }\n              ) => {\n                if (bestPointSoFarIndex === null || bestPointSoFar === null) {\n                  return {\n                    bestPointSoFarIndex: otherPointIndex,\n                    bestPointSoFar: otherPoint,\n                    collinearPoints: collinearPoints,\n                  };\n                }\n                const cp = crossProduct(\n                  vectorFromPoints(currentPoint, bestPointSoFar),\n                  vectorFromPoints(currentPoint, otherPoint)\n                );\n                if (cp > 0) {\n                  return {\n                    bestPointSoFarIndex: otherPointIndex,\n                    bestPointSoFar: otherPoint,\n                    collinearPoints: [],\n                  };\n                } else if (cp === 0) {\n                  if (\n                    distanceSq(currentPoint, otherPoint) >\n                    distanceSq(currentPoint, bestPointSoFar)\n                  ) {\n                    return {\n                      bestPointSoFarIndex: otherPointIndex,\n                      bestPointSoFar: otherPoint,\n                      collinearPoints: [...collinearPoints, bestPointSoFar],\n                    };\n                  } else {\n                    return {\n                      bestPointSoFarIndex,\n                      bestPointSoFar,\n                      collinearPoints: [...collinearPoints, otherPoint],\n                    };\n                  }\n                } else {\n                  return {\n                    bestPointSoFarIndex,\n                    bestPointSoFar,\n                    collinearPoints,\n                  };\n                }\n              }\n            )\n          )\n          .end();\n        if (bestPointSoFarIndex === null || bestPointSoFar === null) {\n          throw new Error(\"unimplemented\");\n        }\n        return {\n          currentPointIndex: bestPointSoFarIndex,\n          currentPoint: bestPointSoFar,\n          result: [...result, currentPoint, ...collinearPoints],\n        };\n      }\n    )\n  )\n    .then(drop(1))\n    .then(\n      findFirstMatching(\n        ({ currentPointIndex }) => currentPointIndex === leftmostPointIndex\n      )\n    )\n    .then((x) => {\n      if (x == null) {\n        throw new Error(\"unreachable\");\n      }\n      return x;\n    })\n    .then(({ result }) => result)\n    .end();\n}\n","import { set } from \"immutable\";\nimport React from \"react\";\nimport { Circle, Layer, Line, Rect, Stage } from \"react-konva\";\nimport convexHull from \"./convexHull\";\nimport Point from \"./util/Point\";\n\nconst width = 500;\nconst height = 500;\nconst radius = 10;\n\nfunction App() {\n  const [points, setPoints] = React.useState<Point[]>([\n    { x: 100, y: 100 },\n    { x: 100, y: 200 },\n    { x: 200, y: 200 },\n    { x: 200, y: 300 },\n  ]);\n\n  function addPoint(point: Point) {\n    setPoints([...points, point]);\n  }\n\n  function setPoint(index: number, point: Point) {\n    setPoints(set(points, index, point));\n  }\n\n  const convexHullPoints = convexHull(points);\n\n  return (\n    <div>\n      <div>\n        <p>Double-click to add a point.</p>\n        <Stage\n          width={width}\n          height={height}\n          onDblClick={(event) => {\n            const pointerPosition = event.target\n              .getStage()\n              ?.getPointerPosition();\n            if (!pointerPosition) {\n              return;\n            }\n            addPoint({ x: pointerPosition.x, y: pointerPosition.y });\n          }}\n        >\n          <Layer>\n            <Rect\n              x={0}\n              y={0}\n              width={width}\n              height={height}\n              stroke={\"black\"}\n            ></Rect>\n          </Layer>\n          <Layer>\n            <Line\n              points={convexHullPoints.flatMap(({ x, y }) => [x, y])}\n              stroke=\"orange\"\n              lineJoin=\"round\"\n              lineCap=\"round\"\n              hitStrokeWidth={0}\n              closed\n            />\n            {convexHullPoints.map(({ x, y }, index) => (\n              <Circle\n                key={index}\n                x={x}\n                y={y}\n                radius={radius * 1.5}\n                fill=\"orange\"\n              />\n            ))}\n          </Layer>\n          <Layer>\n            {points.map((point, index) => (\n              <Circle\n                draggable\n                key={index}\n                x={point.x}\n                y={point.y}\n                radius={radius}\n                fill=\"green\"\n                stroke=\"darkgreen\"\n                onDragMove={(event) => {\n                  setPoint(index, { x: event.target.x(), y: event.target.y() });\n                }}\n              />\n            ))}\n          </Layer>\n        </Stage>\n      </div>\n\n      <h1>Points</h1>\n      <div>\n        <table>\n          <thead>\n            <tr>\n              <td>x</td>\n              <td>y</td>\n            </tr>\n          </thead>\n          <tbody>\n            {points.map((point, index) => (\n              <tr key={index}>\n                <td>\n                  <input\n                    type=\"number\"\n                    value={point.x}\n                    min={0}\n                    max={width}\n                    onChange={(event) => {\n                      setPoint(index, {\n                        x: event.target.valueAsNumber,\n                        y: points[index].y,\n                      });\n                    }}\n                  ></input>\n                </td>\n                <td>\n                  {\n                    <input\n                      type=\"number\"\n                      value={point.y}\n                      min={0}\n                      max={width}\n                      onChange={(event) => {\n                        setPoint(index, {\n                          x: points[index].x,\n                          y: event.target.valueAsNumber,\n                        });\n                      }}\n                    ></input>\n                  }\n                </td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n      <div>\n        <button\n          onClick={() => {\n            setPoints([...points, { x: width / 2, y: height / 2 }]);\n          }}\n        >\n          Add\n        </button>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}